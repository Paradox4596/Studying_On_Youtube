C언어/C++ 무료강의
게시자: 어소트락 게임아카데미
https://www.youtube.com/playlist?list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1

용도: 공부중 암기 할 중요사항 타임라인&메모 기록용

///

C/C++ 강의 1화. 프로젝트 생성 및 주석

///

C/C++ 강의 2화. 자료형

23:29 양수만 표현할지, 음수와 양수 둘 다 표현할 지 명시하기 위해 'unsigned char c' 와 같이 양의 정수만 표현 가능한 공간을 만들 수 있음

///

C/C++ 강의 3화. 정수형 자료형

03:00 char c1의 경우 signed char c1 처럼 signed 키워드가 생략되어 있다고 볼 수 있음

05:15 각각 256가지 수를 표현하는데
unsined char : 0 ~ 255
signed char: -128 ~ 0 ~ 127 까지 표현

7:56 맨 앞 비트를 MSB라고 부름(Most significant bit), 음수 양수 판별 최상위 부호

30:00 음수를 빨리 찾는 법, 2의 보수법

///

C/C++ 강의 5화. 산술 연산자

03:14 %(모듈러스 연산자 or 나머지 연산자)

07:20 레지스터 메모리(cpu가 연산을 할 때 끌어다 쓰는 메모리)

13:20 실수끼리의 나눗셈은 문법 오류가 된다.(10.0 % 3.0 -> 오류)

14:24 나머지 연산자는 피연산자가 모두 정수일 때 만 쓸수 있는 개념

17:49 f를 붙인 것과 안붙인 것의 차이: f를 붙였으면 4byte짜리 float 타입으로 본다는 뜻이고, f를 안붙이고 .만 섰을 경우에는  8byte짜리  double 타입으로 본다는 뜻이다.

19:00 코드상에 직접 숫자를 때려 박는 것을 상수라고 한다

///

C/C++ 강의 6화. 증감 연산자

03:40 포인터에서는 ++ 이나 --가 1씩 증감의 개념이 아니다. 즉 '다음 단계'로 증감한다고 보는 것이 편할 것이다.

07:04 data++(후위 or 후치) -> 모든 연산자 통틀어서 제일 나중에 수행된다. !심지어 대입 연산자보다 늦는 순서!

09:49 다른 연산자와 순서가 섞여있을 때는 앞이냐 뒤냐에 따라 결과가 달라질 수 있다.

10:49 ++ 이나 --는 전위건 후위건 간에 공간 자체 값이 증감한다.(대입 연산자 필요 X)

12:30 다른 연산자와 같이 쓰지 않을 때처럼 크게 상관 없는 상황이더라도, 쓸 때 습관은 둘 중에서 '전위'를 쓰는 것으로 들이자. 안그러면 클래스나 구조체 오퍼레이터에서 효율이 안좋은 함수를 실수로 호출할 가능성이 있다.

///

C/C++ 강의 7화. 논리 연산자

01:30 !(역), &&(곱)->and 연산자, ||(합)->or 연산자
! -> 참을 거짓으로, 거짓을 참으로 만듬
&& -> 양쪽 피 연산자가 둘다 참일 때만 참, 둘중 하나라도 거짓이면 거짓으로 나옴
|| -> 양쪽 피 연산자중 하나만 참이어도 참, 둘다 거짓일 때만 거짓으로 나옴

03:44 참이란? 0이 아닌 모든 값! 보통 대표하는 값은 1

06:11 ture나 false같은 참 거짓 전용 자료형 -> bool, 얘는 굳이 따지자면 정수 타입에 해당한다(0,1을 취급하므로), 크기는 1byte, C에선 없었고 C++에서 추가된 개념

09:15 true <-> false 값 뒤집기

09:55 바로 위 뒤집기 방법이 bool 뿐만 아니라 일반 정수 타입에도 먹힘

11:23 && 예시

16:35 삼항 연산자

16:50 삼항 연산자와 비슷한 역할을 하는 구문

///

C/C++ 강의 8화. if / else 구문

///

C/C++ 강의 9화. switch 구문/ 삼항 연산자

4:18 if / else if 와 switch / case는 거의 차이가 없지만 if / else if 밖에 불가능한 경우가 있음. 반면에 if / else if 같은 경우 조건이 너무 길어지면 코드 가독성이 switch case보다 낮아짐.
두 문법이 둘 다 있는 이유가 있는 것.

7:03 많이 실수 하는 경우 - break가 없으면 쭉 아래 내려가서 default 쪽 작업까지 수행하고 종료가 되버림. 단순 오타이기 대문에 문법오류로 잡히지 않아서 이상 동작이 발생하지만 파악이 어려운 심각한 문제로 번질 수 있음.

8:47 의도적으로 묶어서 사용하는 경우가 있기 때문에 바로 위 문법이 문제가 되지 않는 것임

10:09 셋중 하나만 참이어도 결과는 참이므로 합연산에서 나머지 조건들은 수행할 필요가 없으므로 하지않고 넘어감

13:40 삼항 연산자 형태 - itTest == 20 ? iTest = 100 : iTest = 200;

15:20 바로 위 삼항 연산자 형태를 if else 형태로 나타낸 모습

///

C/C++ 강의 10화. define / 비트 연산자 (1)

09:00
byte <<= 3; // 2^n 배수
byte >>= 2; // 2^n  나눈 몫 (나머지는 버림)

11:40 비트끼리의 연산 // 비트 곱(&), 비트 합(|), xor(^), 반전(~)
곱과 합은 논리 연산자와 비슷하지만 한번씩만 쓴다
반전은 ! -> ~
xor은 각 자리의 비트가 같으면 0 다르면 1
